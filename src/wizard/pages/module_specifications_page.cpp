#include <QLabel>
#include <QLineEdit>
#include <QGridLayout>
#include <QCheckBox>
#include <QRegularExpression>
#include <QRegularExpressionValidator>
#include <QSpacerItem>

#include "module_specifications_page.h"
#include "module_generator_settings.h"
#include "module_generator_logger.h"


const char*
ModuleSpecificationsPage::C_TITLE_SPECIFICATIONS_PAGE = "Module Specifications";

const QString
ModuleSpecificationsPage::S_INFO_TEXT =
        QStringLiteral("Enter the name and version of the module. "
                       "Add a short description and "
                       "optionally define a prefix, which will be placed "
                       "in front of each file and class name.");
const QString
ModuleSpecificationsPage::S_MODULE_PREFIX_LABEL = QStringLiteral("Prefix:");
const QString
ModuleSpecificationsPage::S_CLASS_NAME_LABEL = QStringLiteral("Class name:");
const QString
ModuleSpecificationsPage::S_FILE_NAME_LABEL = QStringLiteral("File name:");
const QString
ModuleSpecificationsPage::S_MODULE_NAME_LABEL = QStringLiteral("Module name:");
const QString
ModuleSpecificationsPage::S_MODULE_VERSION_LABEL =
        QStringLiteral("Module version:");
const QString
ModuleSpecificationsPage::S_MODULE_DESCRIPTION_LABEL =
        QStringLiteral("Module description:");
const QString
ModuleSpecificationsPage:: S_AUTO_COMPLETE_LABEL =
        QStringLiteral("Autogenerate description, file and class name");

const QString
ModuleSpecificationsPage::S_AUTO_GENERATED_TOOLTIP =
        QStringLiteral("Autogenerated using the module name");

/*
 * constructor
 */
ModuleSpecificationsPage::ModuleSpecificationsPage(ModuleGeneratorSettings* settings, QWidget* parent) :
    AbstractWizardPage(settings, parent)
{
    // initializations
    m_prefixValidator = new QRegularExpressionValidator(
                ModuleGeneratorSettings::REG_PREFIX, this);
    m_indentValidator = new QRegularExpressionValidator(
                ModuleGeneratorSettings::REG_OBJECT_NAME, this);
    m_classNameValidator = new QRegularExpressionValidator(
                ModuleGeneratorSettings::REG_CLASS_NAME, this);
    m_fileNameValidator = new QRegularExpressionValidator(
                ModuleGeneratorSettings::REG_FILE_NAME, this);
    m_versionValidator = new QRegularExpressionValidator(
                ModuleGeneratorSettings::REG_VERSION, this);

    auto* infoTextLabel = new QLabel(S_INFO_TEXT);
    auto* modulePrefixLabel = new QLabel(S_MODULE_PREFIX_LABEL);
    auto* classNameLabel = new QLabel(S_CLASS_NAME_LABEL);
    auto* fileNameLabel = new QLabel(S_FILE_NAME_LABEL);
    auto* moduleNameLabel = new QLabel(S_MODULE_NAME_LABEL);
    auto* versionLabel = new QLabel(S_MODULE_VERSION_LABEL);
    auto* descriptionLabel = new QLabel(S_MODULE_DESCRIPTION_LABEL);

    m_modulePrefixEdit = new QLineEdit;
    m_classNameEdit = new QLineEdit;
    m_fileNameEdit = new QLineEdit;
    m_moduleNameEdit = new QLineEdit;
    m_versionEdit = new QLineEdit;
    m_descriptionEdit = new QLineEdit;
    m_autoEditCheckBox = new QCheckBox(S_AUTO_COMPLETE_LABEL);

    auto* baseLayout = new QGridLayout;

    auto* vSpacer = new QSpacerItem(1, 1, QSizePolicy::Minimum,
                                      QSizePolicy::MinimumExpanding);

    // page gui
    setTitle(tr(C_TITLE_SPECIFICATIONS_PAGE));

    infoTextLabel->setWordWrap(true);
    infoTextLabel->setMinimumHeight(AbstractWizardPage::I_INFOTEXTLABEL_HEIGHT);
    infoTextLabel->setAlignment(Qt::AlignTop | Qt::AlignLeft);

    m_modulePrefixEdit->setValidator(m_prefixValidator);
    m_moduleNameEdit->setValidator(m_indentValidator);
    m_classNameEdit->setValidator(m_classNameValidator);
    m_fileNameEdit->setValidator(m_fileNameValidator);
    m_versionEdit->setValidator(m_versionValidator);

    m_fileNameEdit->setEnabled(false);
    m_classNameEdit->setEnabled(false);

    int row = 0;
    baseLayout->addWidget(infoTextLabel, row++, 0, 1, 2);
    baseLayout->addWidget(modulePrefixLabel, row, 0);
    baseLayout->addWidget(m_modulePrefixEdit, row++, 1);
    baseLayout->addWidget(moduleNameLabel, row, 0);
    baseLayout->addWidget(m_moduleNameEdit, row++, 1);
    baseLayout->addWidget(classNameLabel, row, 0);
    baseLayout->addWidget(m_classNameEdit, row++, 1);
    baseLayout->addWidget(fileNameLabel, row, 0);
    baseLayout->addWidget(m_fileNameEdit, row++, 1);
    baseLayout->addWidget(versionLabel, row, 0);
    baseLayout->addWidget(m_versionEdit, row++, 1);
    baseLayout->addWidget(descriptionLabel, row, 0);
    baseLayout->addWidget(m_descriptionEdit, row++, 1);
    baseLayout->addWidget(m_autoEditCheckBox, row++, 0, 1, 2);
    baseLayout->addItem(vSpacer, row++, 0, 1, 2);
    baseLayout->setColumnMinimumWidth(0,
        AbstractWizardPage::I_PAGES_COLUMN_WIDTH);

    setLayout(baseLayout);


    // signals
    connect(m_moduleNameEdit, SIGNAL(textEdited(QString)),
            this, SLOT(onEditedModuleName(QString)));
    connect(m_moduleNameEdit, SIGNAL(textEdited(QString)),
            this,  SIGNAL(completeChanged()));

    connect(m_classNameEdit, SIGNAL(textEdited(QString)),
            this, SLOT(onEditedClassName(QString)));
    connect(m_fileNameEdit, SIGNAL(editingFinished()),
            this, SLOT(onEditedFileName()));

    connect(m_modulePrefixEdit, SIGNAL(textEdited(QString)),
            this,  SIGNAL(completeChanged()));
    connect(m_modulePrefixEdit, SIGNAL(textEdited(QString)),
            this,  SLOT(onEditedPrefix()));

    connect(m_versionEdit, SIGNAL(textEdited(QString)),
            this,  SIGNAL(completeChanged()));
    connect(m_versionEdit, SIGNAL(textEdited(QString)),
            this, SLOT(onEditedVersion(QString)));

    connect(m_autoEditCheckBox, SIGNAL(stateChanged(int)),
            this, SIGNAL(completeChanged()));
    connect(m_autoEditCheckBox, SIGNAL(stateChanged(int)),
            this, SLOT(onAutoCompleteChanged(int)));

    // defaults
    m_autoEditCheckBox->setChecked(true);
    onAutoCompleteChanged(true);
}

/*
 * protected
 */
void
ModuleSpecificationsPage::initializePage()
{
    LOG_INDENT("specifications page...");

    auto& mclass = settings()->moduleClass();

    m_modulePrefixEdit->setText(settings()->modulePrefix());
    m_moduleNameEdit->setText(mclass.ident);
    m_classNameEdit->setText(mclass.className);
    m_fileNameEdit->setText(mclass.fileName);
    m_versionEdit->setText(mclass.version);
    m_descriptionEdit->setText(mclass.description);
}

bool
ModuleSpecificationsPage::isComplete() const
{
    QPalette palette;
    QString prefix = m_modulePrefixEdit->text();

    if (settings()->reservedPrefixes().contains(prefix.toLower()))
    {
        palette.setColor(QPalette::Text, Qt::red);
//        m_modulePrefixEdit->setPalette(palette);
        m_modulePrefixEdit->setToolTip(QStringLiteral("This prefix is already "
                                                      "in use by another module"
                                                      "/GTlab."));

//        return false;
    }
    else
    {
        m_modulePrefixEdit->setToolTip({});
    }

    m_modulePrefixEdit->setPalette(palette);

    int  pos = 0;
    QString version    = m_versionEdit->text();
    QString moduleName = m_moduleNameEdit->text().simplified();

    if (m_versionValidator->validate(version, pos) != QRegExpValidator::Acceptable ||
        m_indentValidator->validate(moduleName, pos) != QRegExpValidator::Acceptable ||
        moduleName.isEmpty() ||
        (!prefix.isEmpty() &&
         m_prefixValidator->validate(prefix, pos) != QRegExpValidator::Acceptable))
    {
        return false;
    }

    return QWizardPage::isComplete();
}

bool
ModuleSpecificationsPage::validatePage()
{
    LOG_INDENT("validated!");

    QString prefix = m_modulePrefixEdit->text();

    ModuleData moduleData;
    moduleData.ident       = m_moduleNameEdit->text().simplified();
    moduleData.className   = m_classNameEdit->text();
    moduleData.fileName    = m_fileNameEdit->text();
    moduleData.description = m_descriptionEdit->text();
    moduleData.version     = m_versionEdit->text();

    static QString version{};
    ModuleData oldModuleData = settings()->moduleClass();

    if (settings()->gtlabVersion() != version ||
        oldModuleData.ident        != moduleData.ident ||
        oldModuleData.className    != moduleData.className ||
        settings()->modulePrefix() != prefix)
    {
        version = settings()->gtlabVersion();
        // clear old interface selection
        settings()->setSelectedInterfaces({});
        emit moduleDataChanged();
    }

    settings()->setModulePrefix(prefix);
    settings()->setModuleClass(moduleData);

    LOG_INFO << "prefix             " << prefix << ENDL;
    LOG_INFO << "module name        " << moduleData.ident << ENDL;
    LOG_INFO << "class name         " << moduleData.className << ENDL;
    LOG_INFO << "file name          " << moduleData.fileName << ENDL;
    LOG_INFO << "module description " << moduleData.description << ENDL;
    LOG_INFO << "module version     " << moduleData.version << ENDL;

    return true;
}

/*
 *  private
 */
void
ModuleSpecificationsPage::autoComplete()
{
    if (!m_autoEditCheckBox->isChecked())
    {
        m_classNameEdit->setEnabled(true);
        m_fileNameEdit->setEnabled(true);
        return;
    }

    m_classNameEdit->setEnabled(false);
    m_fileNameEdit->setEnabled(false);

    QString moduleName = m_moduleNameEdit->text();
    QString prefix     = m_modulePrefixEdit->text();

    m_fileNameEdit->setText(settings()->fileNamingScheme(moduleName,
                                                         prefix));
    m_classNameEdit->setText(settings()->classNamingScheme(moduleName,
                                                           prefix));

    m_fileNameEdit->setToolTip(S_AUTO_GENERATED_TOOLTIP);
    m_classNameEdit->setToolTip(S_AUTO_GENERATED_TOOLTIP);

    QString desc(moduleName);

    if (!prefix.isEmpty())
    {
        prefix.replace(0, 1, prefix.at(0).toUpper());
        desc.prepend(prefix + ' ');
    }

    m_descriptionEdit->setText(desc.simplified());
}

/*
 * private slots
 */
void
ModuleSpecificationsPage::onEditedPrefix()
{
    autoComplete();
}

void
ModuleSpecificationsPage::onEditedModuleName(QString name)
{
    Q_UNUSED(name)
    autoComplete();
}

void
ModuleSpecificationsPage::onEditedClassName(QString name)
{
    Q_UNUSED(name)

    if (m_fileNameEdit->text().isEmpty()) m_autoEditFileName = true;

    if (m_autoEditFileName)
    {
        m_fileNameEdit->setText(m_classNameEdit->text().toLower());
    }
}

void
ModuleSpecificationsPage::onEditedFileName()
{
    m_autoEditFileName = false;
    m_fileNameEdit->setText(m_fileNameEdit->text().toLower());
}

void
ModuleSpecificationsPage::onEditedVersion(QString content)
{
    int pos = 0;
    QPalette palette;

    if (m_versionValidator->validate(content, pos) ==
            QRegExpValidator::Intermediate)
    {
        palette.setColor(QPalette::Text, Qt::red);
        m_versionEdit->setPalette(palette);
    }

    m_versionEdit->setPalette(palette);
}

void
ModuleSpecificationsPage::onAutoCompleteChanged(int state)
{
    bool active = state > 0;

    m_descriptionEdit->setEnabled(!active);
//    m_classNameEdit->setEnabled(!active);
//    m_fileNameEdit->setEnabled(!active);

    autoComplete();
}


